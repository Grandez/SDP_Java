package com.jgg.sdp.parser.lang;

import java_cup.runtime.*;

import com.jgg.sdp.common.config.*;
import com.jgg.sdp.core.ctes.TRAP;

import com.jgg.sdp.module.base.*;
import com.jgg.sdp.module.items.*;
import com.jgg.sdp.module.factorias.*;

import com.jgg.sdp.parser.base.*;
import com.jgg.sdp.parser.code.*;
import com.jgg.sdp.parser.stmt.*;
import com.jgg.sdp.parser.symbols.*;

import com.jgg.sdp.blocks.stmt.*;

import com.jgg.sdp.common.ctes.*;

import com.jgg.sdp.rules.components.*;

parser code {:
   GenericScanner scanner = null;
   Module        module   = ModulesFactory.getDefaultModule();
   Configuration cfg      = ConfigurationBase.getInstance();
   ParserInfo    info     = ParserInfo.getInstance();
             
   public void syntax_error(SDPSymbol token) throws ParseException {
          info.syntax_error(token);
   }

   public void unrecovered_syntax_error(SDPSymbol token) throws ParseException {
      info.unrecovered_syntax_error(token);
   }
   
   public void setScanner(GenericScanner scanner) {
       this.scanner = scanner;
   }
   
:}

action code {:

   RulesCode   rules    = new RulesCode();
   Module      module   = null;
   Persistence fichero  = null;
   ZCCCode     code     = null;
   ParserInfo  info     = ParserInfo.getInstance();
      
   Variable  currVar       = null;
   StmtCobol lastStmt      = null;  // Ultima instruccion
   StmtCobol currStmt      = null;  // Instruccion en proceso
   Option    currOption    = null;  // Option en proceso
   boolean   hasEndProgram = false; // Hay STOPRUN o GOBACK?
    
   boolean master     = false;  // El fichero es el maestro?   
   int     numFillers = 0;
   
   public void initActionClass() {
      module = info.getModule();
      code = new ZCCCode(module);
   }

   public String getSymbolName(Symbol s)    { return (String) s.value; }
   public int    getSymbolLine(Symbol s)    { return (int)    s.left;  }
   
   public void debug(String txt) { 
      System.err.println(txt); 
   }
   public void print(String txt) { 
      System.out.println(txt); 
   }

:}

init with {: action_obj.initActionClass();    :}
scan with {: if (scanner == null) return getScanner().next_token();
             return scanner.tokenCobolCode(); 
          :}

/****************************************************************************/
/****************************************************************************/
/*                           TERMINALES                                    */
/****************************************************************************/
/****************************************************************************/

terminal SDPSymbol PROC_DIV ;

terminal SDPSymbol SYM       ;
terminal SDPSymbol NUMERO    ;
terminal SDPSymbol ENDP      ;
terminal SDPSymbol ENDVERB   ;

//terminal SDPSymbol HEX_VAL   ;
terminal SDPSymbol PARRAFO   ;
terminal SDPSymbol LITERAL   ;
// terminal SDPSymbol LITCONCAT ;
terminal SDPSymbol EXIT_PERFORM ;
terminal SDPSymbol EXIT_PGM     ;
terminal SDPSymbol END_PGM   ;

terminal SDPSymbol STOPRUN       ;

terminal SDPSymbol OP_POW       ;
terminal SDPSymbol OP_MUL       ;
terminal SDPSymbol OP_DIV       ;
terminal SDPSymbol OP_SUB       ;
terminal SDPSymbol OP_ADD       ;
terminal SDPSymbol OP_COLON       ;

terminal SDPSymbol REL_GE  ;
terminal SDPSymbol REL_LE  ;
terminal SDPSymbol REL_GT  ;
terminal SDPSymbol REL_LT  ;
terminal SDPSymbol REL_EQ  ;

terminal SDPSymbol GOTO    ;

// RESERVED WORDS

terminal SDPSymbol ACCEPT              ;
terminal SDPSymbol ACCESS              ;
terminal SDPSymbol ADD                 ;
terminal SDPSymbol ADDRESS             ;
terminal SDPSymbol ADVANCING           ;
terminal SDPSymbol AFTER               ;
terminal SDPSymbol ALL                 ;
terminal SDPSymbol ALPHABET            ;
terminal SDPSymbol ALPHABETIC          ;
terminal SDPSymbol ALPHABETIC_LOWER    ;
terminal SDPSymbol ALPHABETIC_UPPER    ;
terminal SDPSymbol ALPHANUMERIC        ;
terminal SDPSymbol ALPHANUMERIC_EDITED ;
terminal SDPSymbol ALSO                ;
terminal SDPSymbol ALTER               ;
terminal SDPSymbol ALTERNATE           ;
terminal SDPSymbol AND                 ;
terminal SDPSymbol ANY                 ;
terminal SDPSymbol APPLY               ;
terminal SDPSymbol ARE                 ;
terminal SDPSymbol AREA                ;
terminal SDPSymbol AREAS               ;
terminal SDPSymbol ASCENDING           ;
terminal SDPSymbol ASSIGN              ;
terminal SDPSymbol AT                  ;
terminal SDPSymbol AUTHOR              ;
terminal SDPSymbol BASIS               ;
terminal SDPSymbol BEFORE              ;
terminal SDPSymbol BEGINNING           ;
terminal SDPSymbol BINARY              ;
terminal SDPSymbol BLANK               ;
terminal SDPSymbol BLOCK               ;
terminal SDPSymbol BOTTOM              ;
terminal SDPSymbol BY                  ;
terminal SDPSymbol CALL                ;
terminal SDPSymbol CANCEL              ;
terminal SDPSymbol CBL                 ;
terminal SDPSymbol CHARACTER           ;
terminal SDPSymbol CHARACTERS          ;
terminal SDPSymbol CLASS_ID            ;
terminal SDPSymbol CLOSE               ;
terminal SDPSymbol COBOL               ;
terminal SDPSymbol CODE                ;
terminal SDPSymbol CODE_SET            ;
terminal SDPSymbol COLLATING           ;
terminal SDPSymbol COM_REG             ;
terminal SDPSymbol COMMA               ;
terminal SDPSymbol COMMON              ;
terminal SDPSymbol COMP                ;
terminal SDPSymbol COMPUTE             ;
terminal SDPSymbol CONTAINS            ;
terminal SDPSymbol CONTENT             ;
terminal SDPSymbol CONTINUE            ;
terminal SDPSymbol CONVERTING          ;
//terminal SDPSymbol COPY                ;
terminal SDPSymbol CORR                ;
terminal SDPSymbol CORRESPONDING       ;
terminal SDPSymbol COUNT               ;
terminal SDPSymbol CURRENCY            ;
terminal SDPSymbol DATA                ;
terminal SDPSymbol DATE                ;
terminal SDPSymbol DAY                 ;
terminal SDPSymbol DAY_OF_WEEK         ;
terminal SDPSymbol DBCS                ;
terminal SDPSymbol DEBUG_CONTENTS      ;
terminal SDPSymbol DEBUG_ITEM          ;
terminal SDPSymbol DEBUG_LINE          ;
terminal SDPSymbol DEBUG_NAME          ;
terminal SDPSymbol DEBUG_SUB           ;
terminal SDPSymbol DEBUGGING           ;
terminal SDPSymbol DECLARATIVES        ;
terminal SDPSymbol DELETE              ;
terminal SDPSymbol DELIMITED           ;
terminal SDPSymbol DELIMITER           ;
terminal SDPSymbol DEPENDING           ;
terminal SDPSymbol DESCENDING          ;
terminal SDPSymbol DISPLAY             ;
terminal SDPSymbol DISPLAY_1           ;
terminal SDPSymbol DIVIDE              ;
terminal SDPSymbol DOWN                ;
terminal SDPSymbol DUPLICATES          ;
terminal SDPSymbol DYNAMIC             ;
terminal SDPSymbol EGCS                ;
terminal SDPSymbol ELSE                ;
terminal SDPSymbol END                 ;
terminal SDPSymbol END_OF_PAGE         ;
terminal SDPSymbol ENDING              ;
terminal SDPSymbol ENTER               ;
terminal SDPSymbol ENTRY               ;
terminal SDPSymbol ENVIRONMENT         ;
terminal SDPSymbol EOP                 ;
terminal SDPSymbol EQUAL               ;
terminal SDPSymbol ERROR               ;
terminal SDPSymbol EVALUATE            ;
terminal SDPSymbol EVERY               ;
terminal SDPSymbol EXCEPTION           ;
terminal SDPSymbol EXEC                ;
terminal SDPSymbol EXECUTE             ;
terminal SDPSymbol EXIT                ;
terminal SDPSymbol EXTEND              ;
terminal SDPSymbol EXTERNAL            ;
terminal SDPSymbol FACTORY             ;
terminal SDPSymbol FALSE               ;
// terminal SDPSymbol FD                  ;
terminal SDPSymbol FILE                ;
// terminal SDPSymbol FILE_CONTROL        ;
terminal SDPSymbol FILLER              ;
terminal SDPSymbol FIRST               ;
terminal SDPSymbol FOOTING             ;
terminal SDPSymbol FOR                 ;
terminal SDPSymbol FROM                ;
terminal SDPSymbol FUNCTION            ;
terminal SDPSymbol FUNCTION_POINTER    ;
terminal SDPSymbol GENERATE            ;
terminal SDPSymbol GIVING              ;
terminal SDPSymbol GLOBAL              ;
terminal SDPSymbol GO                  ;
terminal SDPSymbol GOBACK              ;
terminal SDPSymbol GREATER             ;
terminal SDPSymbol GROUP_USAGE         ;
terminal SDPSymbol HIGHVAL             ;
terminal SDPSymbol IO                 ;
// terminal SDPSymbol IO_CONTROL         ;
terminal SDPSymbol ID                  ;
terminal SDPSymbol IDENTIFICATION      ;
terminal SDPSymbol IF                  ;
terminal SDPSymbol IN                  ;
terminal SDPSymbol INDEX               ;
terminal SDPSymbol INDEXED             ;
terminal SDPSymbol INHERITS            ;
terminal SDPSymbol INITIAL             ;
terminal SDPSymbol INITIALIZE          ;
terminal SDPSymbol INPUT               ;
terminal SDPSymbol INPUT_OUTPUT        ;
terminal SDPSymbol INSERT              ;
terminal SDPSymbol INSPECT             ;
terminal SDPSymbol INSTALLATION        ;
terminal SDPSymbol INTO                ;
terminal SDPSymbol INVALID             ;
terminal SDPSymbol INVOKE              ;
terminal SDPSymbol JNIENVPTR           ;
terminal SDPSymbol JUST                ;
terminal SDPSymbol JUSTIFIED           ;
terminal SDPSymbol KANJI               ;
terminal SDPSymbol KEY                 ;
terminal SDPSymbol LABEL               ;
terminal SDPSymbol LEADING             ;
terminal SDPSymbol LEFT                ;
terminal SDPSymbol LENGTH              ;
terminal SDPSymbol LESS                ;
terminal SDPSymbol LINAGE              ;
terminal SDPSymbol LINAGE_COUNTER      ;
terminal SDPSymbol LINE                ;
terminal SDPSymbol LINES               ;
terminal SDPSymbol LINKAGE             ;
terminal SDPSymbol LOCAL_STORAGE       ;
terminal SDPSymbol LOCK                ;
terminal SDPSymbol LOWVAL              ;
terminal SDPSymbol MEMORY              ;
terminal SDPSymbol MERGE               ;
terminal SDPSymbol METHOD              ;
terminal SDPSymbol METHOD_ID           ;
terminal SDPSymbol MODE                ;
terminal SDPSymbol MODULES             ;
terminal SDPSymbol MORE_LABELS         ;
terminal SDPSymbol MOVE                ;
terminal SDPSymbol MULTIPLE            ;
terminal SDPSymbol MULTIPLY            ;
terminal SDPSymbol NATIONAL            ;
// terminal SDPSymbol NATIONAL_EDITED     ;
terminal SDPSymbol NATIVE              ;
terminal SDPSymbol NEGATIVE            ;
terminal SDPSymbol NEXT                ;
terminal SDPSymbol NO                  ;
terminal SDPSymbol NOT                 ;
terminal SDPSymbol NULL                ;
terminal SDPSymbol NULLS               ;
terminal SDPSymbol NUMERIC             ;
terminal SDPSymbol NUMERIC_EDITED      ;
terminal SDPSymbol OBJECT              ;
terminal SDPSymbol OCCURS              ;
terminal SDPSymbol OF                  ;
terminal SDPSymbol OFF                 ;
terminal SDPSymbol OMITTED             ;
terminal SDPSymbol ON                  ;
terminal SDPSymbol OPEN                ;
terminal SDPSymbol OPTIONAL            ;
terminal SDPSymbol OR                  ;
terminal SDPSymbol ORDER               ;
terminal SDPSymbol ORGANIZATION        ;
terminal SDPSymbol OTHER               ;
terminal SDPSymbol OUTPUT              ;
terminal SDPSymbol OVERFLOW            ;
terminal SDPSymbol OVERRIDE            ;
terminal SDPSymbol PACKED_DECIMAL      ;
terminal SDPSymbol PADDING             ;
terminal SDPSymbol PAGE                ;
terminal SDPSymbol PASSWORD            ;
terminal SDPSymbol PERFORM             ;
terminal SDPSymbol PIC                 ;
terminal SDPSymbol PICTURE             ;
terminal SDPSymbol POINTER             ;
terminal SDPSymbol POSITION            ;
terminal SDPSymbol POSITIVE            ;
terminal SDPSymbol PROCEDURE           ;
terminal SDPSymbol PROCEDURE_POINTER   ;
terminal SDPSymbol PROCEDURES          ;
terminal SDPSymbol PROCEED             ;
terminal SDPSymbol PROCESSING          ;
terminal SDPSymbol PROGRAM             ;
terminal SDPSymbol PROGRAM_ID          ;
terminal SDPSymbol QUOTE               ;
terminal SDPSymbol QUOTES              ;
terminal SDPSymbol RANDOM              ;
terminal SDPSymbol READ                ;
terminal SDPSymbol READY               ;
terminal SDPSymbol RECORD              ;
terminal SDPSymbol RECORDING           ;
terminal SDPSymbol RECORDS             ;
terminal SDPSymbol RECURSIVE           ;
terminal SDPSymbol REEL                ;
terminal SDPSymbol REFERENCE           ;
terminal SDPSymbol REFERENCES          ;
terminal SDPSymbol RELATIVE            ;
terminal SDPSymbol RELEASE             ;
terminal SDPSymbol RELOAD              ;
terminal SDPSymbol REMAINDER           ;
terminal SDPSymbol RENAMES             ;
terminal SDPSymbol REPLACE             ;
terminal SDPSymbol REPLACING           ;
terminal SDPSymbol REPOSITORY          ;
terminal SDPSymbol RERUN               ;
terminal SDPSymbol RESERVE             ;
terminal SDPSymbol RESET               ;
terminal SDPSymbol RETURN              ;
terminal SDPSymbol RETURN_CODE         ;
terminal SDPSymbol RETURNING           ;
terminal SDPSymbol REVERSED            ;
terminal SDPSymbol REWIND              ;
terminal SDPSymbol REWRITE             ;
terminal SDPSymbol RIGHT               ;
terminal SDPSymbol ROUNDED             ;
terminal SDPSymbol RUN                 ;
terminal SDPSymbol SAME                ;
terminal SDPSymbol SEARCH              ;
terminal SDPSymbol SECTION             ;
terminal SDPSymbol SECURITY            ;
terminal SDPSymbol SELECT              ;
terminal SDPSymbol SELF                ;
terminal SDPSymbol SENTENCE            ;
terminal SDPSymbol SEPARATE            ;
terminal SDPSymbol SEQUENCE            ;
terminal SDPSymbol SEQUENTIAL          ;
terminal SDPSymbol SERVICE             ;
terminal SDPSymbol SET                 ;
terminal SDPSymbol SHIFT_IN            ;
terminal SDPSymbol SHIFT_OUT           ;
terminal SDPSymbol SIGN                ;
terminal SDPSymbol SIZE                ;
terminal SDPSymbol SORT                ;
terminal SDPSymbol SORT_CONTROL        ;
terminal SDPSymbol SORT_CORE_SIZE      ;
terminal SDPSymbol SORT_FILE_SIZE      ;
terminal SDPSymbol SORT_MERGE          ;
terminal SDPSymbol SORT_MESSAGE        ;
terminal SDPSymbol SORT_MODE_SIZE      ;
terminal SDPSymbol SORT_RETURN         ;
// terminal SDPSymbol SPACE               ;
terminal SDPSymbol SPACES              ;
// terminal SDPSymbol SPECIAL_NAMES       ;
terminal SDPSymbol SQL                 ;
terminal SDPSymbol STANDARD            ;
//terminal SDPSymbol STANDARD_1          ;
//terminal SDPSymbol STANDARD_2          ;
terminal SDPSymbol START               ;
terminal SDPSymbol STATUS              ;
terminal SDPSymbol STOP                ;
terminal SDPSymbol STRING              ;
terminal SDPSymbol SUBTRACT            ;
terminal SDPSymbol SUPER               ;
terminal SDPSymbol SUPPRESS            ;
terminal SDPSymbol SYMBOLIC            ;
terminal SDPSymbol SYNC                ;
terminal SDPSymbol SYNCHRONIZED        ;
terminal SDPSymbol TALLY               ;
terminal SDPSymbol TALLYING            ;
terminal SDPSymbol TAPE                ;
terminal SDPSymbol TEST                ;
terminal SDPSymbol THAN                ;
terminal SDPSymbol THEN                ;
terminal SDPSymbol THROUGH             ;
terminal SDPSymbol THRU                ;
terminal SDPSymbol TIME                ;
terminal SDPSymbol TIMES               ;
terminal SDPSymbol TITLE               ;
terminal SDPSymbol TO                  ;
terminal SDPSymbol TOP                 ;
terminal SDPSymbol TRACE               ;
terminal SDPSymbol TRAILING            ;
terminal SDPSymbol TRUE                ;
terminal SDPSymbol TYPE                ;
terminal SDPSymbol UNIT                ;
terminal SDPSymbol UNSTRING            ;
terminal SDPSymbol UNTIL               ;
terminal SDPSymbol UP                  ;
terminal SDPSymbol UPON                ;
terminal SDPSymbol USE                 ;
terminal SDPSymbol USING               ;
terminal SDPSymbol VALUE               ;
terminal SDPSymbol VALUES              ;
terminal SDPSymbol VARYING             ;
terminal SDPSymbol WHEN                ;
terminal SDPSymbol WITH                ;
terminal SDPSymbol WORDS               ;
terminal SDPSymbol WRITE               ;
terminal SDPSymbol WRITE_ONLY          ;
terminal SDPSymbol XML                 ;
terminal SDPSymbol XML_CODE            ;
terminal SDPSymbol XML_EVENT           ;
terminal SDPSymbol XML_NAMESPACE       ;
terminal SDPSymbol XML_NAMESPACE_PREFIX;
terminal SDPSymbol XML_NNAMESPACE      ;
terminal SDPSymbol XML_NNAMESPACE_PREFIX;
terminal SDPSymbol XML_NTEXT           ;
terminal SDPSymbol XML_SCHEMA          ;
terminal SDPSymbol XML_TEXT            ;
terminal SDPSymbol ZERO                ;
// terminal SDPSymbol ZEROES              ;
// terminal SDPSymbol ZEROS               ;

// RESERVED WORDS IN ISO COBOL BUT NO IN ZCOBOL

// terminal SDPSymbol CD                  ;
// terminal SDPSymbol CF                  ;
// terminal SDPSymbol CH                  ;
// terminal SDPSymbol CLOCK_UNITS         ;
// terminal SDPSymbol COLUMN              ;
// terminal SDPSymbol COMMUNICATION       ;
// terminal SDPSymbol CONTROL             ;
// terminal SDPSymbol CONTROLS            ;
// terminal SDPSymbol DE                  ;
// terminal SDPSymbol DESTINATION         ;
// terminal SDPSymbol DETAIL              ;
// terminal SDPSymbol DISABLE             ;
// terminal SDPSymbol EGI                 ;
// terminal SDPSymbol EMI                 ;
// terminal SDPSymbol ENABLE              ;
// terminal SDPSymbol ESI                 ;
// terminal SDPSymbol FINAL               ;
// terminal SDPSymbol GROUP               ;
// terminal SDPSymbol HEADING             ;
// terminal SDPSymbol INDICATE            ;
// terminal SDPSymbol INITIATE            ;
// terminal SDPSymbol LAST                ;
// terminal SDPSymbol LIMIT               ;
// terminal SDPSymbol LIMITS              ;
// terminal SDPSymbol LINE_COUNTER        ;
// terminal SDPSymbol MESSAGE             ;
// terminal SDPSymbol NUMBER              ;
// terminal SDPSymbol PAGE_COUNTER        ;
// terminal SDPSymbol PF                  ;
// terminal SDPSymbol PH                  ;
// terminal SDPSymbol PLUS                ;
// terminal SDPSymbol PRINTING            ;
// terminal SDPSymbol PURGE               ;
// terminal SDPSymbol QUEUE               ;
// terminal SDPSymbol RD                  ;
// terminal SDPSymbol RECEIVE             ;
// terminal SDPSymbol REPORT              ;
// terminal SDPSymbol REPORTING           ;
// terminal SDPSymbol REPORTS             ;
// terminal SDPSymbol RF                  ;
// terminal SDPSymbol RH                  ;
// terminal SDPSymbol SEGMENT             ;
// terminal SDPSymbol SEND                ;
// terminal SDPSymbol SOURCE              ;
// terminal SDPSymbol SUB_QUEUE_1         ;
// terminal SDPSymbol SUB_QUEUE_2         ;
// terminal SDPSymbol SUB_QUEUE_3         ;
// terminal SDPSymbol SUM                 ;
// terminal SDPSymbol TABLE               ;
// terminal SDPSymbol TERMINAL            ;
// terminal SDPSymbol TERMINATE           ;
// terminal SDPSymbol TEXT                ;

// FUTURE RESERVED WORDS IN ZCOBOL

// terminal SDPSymbol ACTIVE_CLASS        ;
// terminal SDPSymbol ALIGNED             ;
// terminal SDPSymbol ALLOCATE            ;
// terminal SDPSymbol ANYCASE             ;
// terminal SDPSymbol B_AND               ;
// terminal SDPSymbol B_NOT               ;
// terminal SDPSymbol B_OR                ;
// terminal SDPSymbol B_XOR               ;
// terminal SDPSymbol BASED               ;
// terminal SDPSymbol BINARY_CHAR         ;
// terminal SDPSymbol BINARY_DOUBLE       ;
// terminal SDPSymbol BINARY_LONG         ;
// terminal SDPSymbol BINARY_SHORT        ;
// terminal SDPSymbol BIT                 ;
// terminal SDPSymbol BOOLEAN             ;
// terminal SDPSymbol COL                 ;
// terminal SDPSymbol COLS                ;
// terminal SDPSymbol COLUMNS             ;
// terminal SDPSymbol CONDITION           ;
// terminal SDPSymbol CONSTANT            ;
// terminal SDPSymbol CRT                 ;
// terminal SDPSymbol CURSOR              ;
// terminal SDPSymbol DATA_POINTER        ;
// terminal SDPSymbol DEFAULT             ;
// terminal SDPSymbol EC                  ;
// terminal SDPSymbol EO                  ;
// terminal SDPSymbol EXCEPTION_OBJECT    ;
// terminal SDPSymbol FLOAT_EXTENDED      ;
// terminal SDPSymbol FLOAT_LONG          ;
// terminal SDPSymbol FLOAT_SHORT         ;
// terminal SDPSymbol FORMAT              ;
// terminal SDPSymbol FREE                ;
// terminal SDPSymbol FUNCTION_ID         ;
// terminal SDPSymbol GET                 ;
// terminal SDPSymbol INTERFACE           ;
// terminal SDPSymbol INTERFACE_ID        ;
// terminal SDPSymbol LOCALE              ;
// terminal SDPSymbol MINUS               ;
// terminal SDPSymbol NESTED              ;
// terminal SDPSymbol OBJECT_REFERENCE    ;
// terminal SDPSymbol OPTIONS             ;
// terminal SDPSymbol PRESENT             ;
// terminal SDPSymbol PROGRAM_POINTER     ;
// terminal SDPSymbol PROPERTY            ;
// terminal SDPSymbol PROTOTYPE           ;
// terminal SDPSymbol RAISE               ;
// terminal SDPSymbol RAISING             ;
// terminal SDPSymbol RESUME              ;
// terminal SDPSymbol RETRY               ;
// terminal SDPSymbol SCREEN              ;
// terminal SDPSymbol SHARING             ;
// terminal SDPSymbol SOURCES             ;
// terminal SDPSymbol SYSTEM_DEFAULT      ;
// terminal SDPSymbol TYPEDEF             ;
// terminal SDPSymbol UNIVERSAL           ;
// terminal SDPSymbol UNLOCK              ;
// terminal SDPSymbol USER_DEFAULT        ;
// terminal SDPSymbol VAL_STATUS          ;
// terminal SDPSymbol VALID               ;
// terminal SDPSymbol VALIDATE            ;
// terminal SDPSymbol VALIDATE_STATUS     ;

/* Simbolos gramaticales y palabras comunes */

terminal SDPSymbol LPAR   ;
terminal SDPSymbol RPAR   ;

terminal SDPSymbol SIZE_ERROR  ;

terminal SDPSymbol INTRINSIC ;

terminal SDPSymbol CICSCODE ;
terminal SDPSymbol SQLCODE  ;
terminal SDPSymbol ENDEXEC  ;

/* CICS  Caso especial DFHxxx*/

terminal SDPSymbol DFHCICS ;

///////////////////////////////////////////////////////
// Division 
///////////////////////////////////////////////////////

non terminal procedure_division  ;
non terminal end_program         ;

non terminal        proc_div_header ; 
non terminal        bloque_procedure;

//////////////////////////////////////////////////////
// No terminales para comerse el resto de sentencias
/////////////////////////////////////////////////////

non terminal StmtCobol stmtAccept  ;
non terminal StmtCobol accept_verb ;
non terminal           accept_from ;
non terminal           accept_data ;

non terminal Statement add_verb     ;
non terminal Tokens add_options_opt ;
non terminal Tokens add_options     ;
non terminal Tokens add_option      ;

non terminal SDPSymbol compute_lvalue  ;
non terminal SDPSymbol compute_rvalues ;
non terminal SDPSymbol compute_rvalue  ;
non terminal SDPSymbol compute_options_opt ;
non terminal SDPSymbol compute_options     ;
non terminal SDPSymbol compute_option      ;

non terminal StmtCobol stmtDivide        ;
non terminal StmtCobol divide_verb       ;
non terminal SDPSymbol    divide_mode       ;
non terminal Option    divide_options_opt;
non terminal Option    divide_options    ;
non terminal Option    divide_option     ;

non terminal StmtCobol stmtInitialize     ;
non terminal StmtCobol initialize_verb    ;
non terminal           initialize_detail  ;
non terminal           initialize_rep_opt ;
non terminal           initialize_rep_lst ;
non terminal           initialize_rep     ;
non terminal           initialize_rep_val ;

non terminal Tokens stmtMultiply_detail  ;
non terminal Tokens stmtMultiply_by      ;
non terminal        multiply_options_opt ;
non terminal        multiply_options     ;
non terminal        multiply_option      ;
                   
non terminal StmtCobol stmtRead            ;                   
non terminal Tokens    stmtRead_detail     ;
non terminal Tokens    stmtRead_options    ;
non terminal Tokens    stmtRead_option     ;
non terminal Tokens    stmtRead_into       ;
non terminal Tokens    stmtRead_key        ;

non terminal StmtCobol stmtSearch         ;
non terminal StmtCobol search_verb        ;
non terminal Tokens    search_detail  ;
non terminal Tokens    search_options ;
non terminal Tokens    search_option  ;
non terminal Tokens    search_opt     ;
non terminal Tokens    search_varying ;

non terminal StmtCobol stmtSort ;
non terminal stmtSort_detail ;
non terminal stmtSort_option ;
non terminal stmtSort_order  ;
non terminal stmtSort_duplicates  ;
non terminal stmtSort_using  ;
non terminal stmtSort_giving ;
non terminal stmtSort_procedure ;


non terminal StmtCobol stmtStart               ;
non terminal Tokens    stmtStart_key           ;

non terminal StmtCobol stmtString       ;
non terminal StmtCobol string_verb      ;
non terminal           string_from      ;
non terminal           string_from_item ; 
non terminal           string_delimited       ;
non terminal           string_delimited_token ;
non terminal           string_into            ;
non terminal           string_pointer_opt     ;

non terminal StmtCobol stmtSubtract           ; 
non terminal Tokens    stmtSubtract_detail    ;
non terminal Tokens    stmtSubtract_options   ;
non terminal Tokens    stmtSubtract_option    ;

non terminal Tokens stmtUnstring_detail          ;
non terminal Tokens stmtUnstring_delimited_opt   ;
non terminal Tokens stmtUnstring_to              ;
non terminal Tokens stmtUnstring_targets         ;
non terminal Tokens stmtUnstring_target          ;  
non terminal Tokens stmtUnstring_delimited       ;
non terminal Tokens stmtUnstring_delimiteds      ;
non terminal Tokens stmtUnstring_delimited_token ;
non terminal Tokens stmtUnstring_delimiters_opt  ;
non terminal Tokens stmtUnstring_delimiters      ;
non terminal Tokens stmtUnstring_delimiter       ;
non terminal Tokens stmtUnstring_options_opt     ;
non terminal Tokens stmtUnstring_options         ;
non terminal Tokens stmtUnstring_option          ;

non terminal        stmtWrite_detail   ;
non terminal        stmtWrite_options  ;
non terminal        stmtWrite_option   ; 
non terminal        stmtWrite_from     ;
non terminal        stmtWrite_position ;
non terminal        stmtWrite_after    ;
non terminal        stmtWrite_eop      ;

non terminal        option_position     ;
non terminal        option_order        ;

                   
non terminal Tokens eatClose   , eatCloseLst , eatCloseItem ;
non terminal Tokens eatWrite   , eatWriteLst , eatWriteItem ;

//////////////////////////////////////////////////////
// Generales
/////////////////////////////////////////////////////

non terminal StmtCobol cobolCode   ; 
non terminal           module      ;

/* Parrafos y sentencias */

non terminal lista_parrafos , bloque_parrafos  , bloque_parrafo ;
non terminal         bloque_inicial ; 
non terminal Integer bloque_sentences ;
non terminal SDPSymbol  parrafo_name ;
non terminal Boolean parr_section;

non terminal SDPSymbol exitType;

non terminal           lista_stmt ;
non terminal StmtCobol stmt       ;
non terminal StmtCobol verbos     ;
non terminal StmtCobol noverbos   ;
non terminal StmtCobol directives ;
non terminal StmtCobol dir_trace  ;

non terminal Tokens    resto_call      ;
non terminal Tokens    list_parms_opt  ;
non terminal Tokens    list_parms      ;
non terminal Tokens    proc_parms_list ;
non terminal Tokens    proc_parms      ;
non terminal Tokens    proc_parm       ;

non terminal StmtCobol stmtMerge      ;
non terminal StmtCobol stmtUnstring   ;
non terminal StmtCobol stmtClose      ;
non terminal StmtCobol stmtCompute    ;
non terminal StmtCobol stmtDelete     ;
non terminal StmtCobol stmtDisplay    ;

non terminal StmtCobol stmtContinue    ;
non terminal StmtCobol stmtGoback      ;
non terminal StmtCobol stmtExit        ;
non terminal StmtCobol stmtExitP       ; 
non terminal StmtCobol stmtExitG       ;
non terminal StmtCobol stmtExitPgm     ;
non terminal StmtCobol exitTypes       ;
non terminal StmtCobol stmtEvaluate    ;
non terminal StmtCobol evaluate_verb   ;
non terminal StmtCobol evaluate_object ;
non terminal StmtCobol when_condition ;
non terminal StmtCobol when_item      ;

non terminal SDPSymbol    when_other     ;

non terminal StmtCobol stmtPerform           ; 
non terminal StmtCobol perform_verb          ;
non terminal Option    perform_from      ;
non terminal Option    perform_options_opt   ;
non terminal Option    perform_options       ;
non terminal Option    perform_options_label_opt ;
non terminal Option    perform_options_label ;
non terminal Option    perform_option_times  ;
non terminal Option    perform_option_first  ;
non terminal Option    perform_option_second ;
non terminal           perform_label         ;
non terminal Option    perform_test          ;
non terminal Option    perform_until         ;
non terminal Option    perform_thru          ;
non terminal Option    perform_varying       ;
non terminal Option    perform_after         ;

non terminal StmtCobol stmtRelease  ;

non terminal StmtCobol stmtGoTo               ;
non terminal           stmtGoto_procs         ;
non terminal           stmtGoto_depending_opt ;
non terminal           stmtGoto_depending     ;
 
non terminal StmtCobol stmtRewrite      ;

non terminal StmtCobol stmtMove         ;
non terminal StmtCobol move_verb        ;

non terminal StmtCobol stmtMultiply   ;

non terminal StmtCobol stmtNext       ;
non terminal StmtCobol stmtCancel     ;
non terminal StmtCobol stmtWrite      ;
non terminal StmtCobol stmtOpen       ;

non terminal StmtCobol stmtInspect                ; 
non terminal           stmtInspect_detail         ;
non terminal           stmtInspect_token          ;

non terminal StmtCobol stmtCall               ;
non terminal           stmtCall_using_opt     ;
non terminal           stmtCall_using         ;
non terminal           stmtCall_returning_opt ;
non terminal           stmtCall_returning     ;
non terminal           stmtCall_parm_list     ;
non terminal           stmtCall_parm          ;
non terminal           stmtCall_parm_type     ;

non terminal SDPSymbol    moduloCall ;

non terminal StmtCobol stmtEndP      ;

non terminal StmtCobol stmtCics      ;
non terminal StmtCobol stmtSQL       ;

non terminal StmtCobol stmtReturn ;             
non terminal StmtCobol stmtStop   ;             
non terminal StmtCobol stmtAdd    ;             
//non terminal StmtCobol stmtTest    ;
             
non terminal StmtCobol stmtSet       ;       
non terminal StmtCobol set_verb      ;
non terminal           set_list      ;
non terminal           set_item      ;
non terminal           set_lvalue    ;
non terminal           set_rvalue    ;
non terminal           set_variable  ;
non terminal           set_value     ;
non terminal           set_index     ;
non terminal           set_index_inc ;

non terminal StmtCobol optionOverflow     ;

non terminal StmtCobol stmtAtEnd;
non terminal StmtCobol stmtInvalid;
non terminal StmtCobol stmtException;

non terminal StmtCobol stmtIf    ;
non terminal StmtCobol if_verb   ;
non terminal StmtCobol stmtElse  ;

non terminal StmtCobol stmtWhen  ;
non terminal StmtCobol when_verb ;
non terminal Tokens    when_thru ;

non terminal StmtCobol stmtDatos   ;
non terminal StmtCobol stmtIO      ;
non terminal StmtCobol stmtIO1     ;
non terminal StmtCobol stmtIO2     ;
non terminal StmtCobol stmtControl ;
non terminal StmtCobol stmtControl1 ;
non terminal StmtCobol  stmtControl2 ;
non terminal StmtCobol stmtFlujo   ;
non terminal StmtCobol stmtArit    ; 
non terminal StmtCobol stmtLang    ;

/** OPEN ***/

non terminal Tokens    stmtOpen_files ;
non terminal Tokens    stmtOpen_list ,  stmtOpen_group ;
non terminal StmtCobol stmtOpen_mode     ;

non terminal Tokens closeFile , closeLstFiles ;

non terminal SDPSymbol stmtEndVerb ;         

non terminal SDPSymbol expression         ;
non terminal SDPSymbol expression_arit    ;
non terminal SDPSymbol expr_colon         ;
non terminal SDPSymbol expr_colon_opt     ;
non terminal SDPSymbol expr_colon_value   ;
non terminal SDPSymbol expr_operand       ;
non terminal SDPSymbol expr_primary       ;

non terminal SDPSymbol logical_condition  ;
non terminal SDPSymbol logical_begin      ;
non terminal SDPSymbol logical_next       ;
non terminal SDPSymbol logical_and_or     ;
non terminal SDPSymbol logical_op_opt     ;
non terminal SDPSymbol logical_op         ;
non terminal SDPSymbol logical_oper       ;
non terminal SDPSymbol logical_oper_not   ;
non terminal SDPSymbol logical_oper_not_value ;
non terminal SDPSymbol logical_oper_or_opt;

non terminal SDPSymbol logical_not        ;
non terminal SDPSymbol logical_yes        ;

non terminal SDPSymbol logical_class      ;
non terminal SDPSymbol logical_unary_not  ;
non terminal SDPSymbol logical_unary      ;
non terminal SDPSymbol logical_figurative ;
non terminal SDPSymbol logical_rel        ;
non terminal SDPSymbol logical_expr       ;
non terminal SDPSymbol logical_operand    ;

non terminal SDPSymbol logical_relation ;
non terminal SDPSymbol operator_arit      ;

/***********************************************************/
/*    OTRAS SENTENCIAS                                     */
/***********************************************************/

non terminal SDPSymbol      function               ;
non terminal SDPSymbol  function_parms         ;
non terminal SDPSymbol  function_parms_lst_opt ;
non terminal SDPSymbol  function_parms_lst     ;
non terminal SDPSymbol   function_parm          ;


non terminal SDPSymbol   rvalue      ;
non terminal SDPSymbol   figurative  ;
non terminal SDPSymbol   constantes  ;
non terminal SDPSymbol   constante   ;

non terminal SDPSymbol   lvalue      ; 
non terminal SDPSymbol  lvalue_list ; 
non terminal SDPSymbol  rvalue_list ;

non terminal SDPSymbol   variable               ;
non terminal SDPSymbol   var_base               ;
non terminal SDPSymbol   var_int                ;

non terminal SDPSymbol   id                     ;
non terminal SDPSymbol   literal                ;
non terminal SDPSymbol   indices_opt            ;
non terminal SDPSymbol   indices                ;
non terminal SDPSymbol   indice                 ;
non terminal SDPSymbol   indice_lst             ;
non terminal SDPSymbol   indice_item            ;
non terminal SDPSymbol   padres_opt             ;
non terminal SDPSymbol   padres                 ;
non terminal SDPSymbol   padre                  ;

non terminal Option rvalue_options_opt  ;
non terminal Option rvalue_options      ;
non terminal Option rvalue_option       ;
non terminal Option option_all          ;
non terminal Option option_corr         ; 
non terminal Option option_giving       ;
non terminal Option option_remainder    ;
non terminal Option option_rounded      ;

non terminal Option option_size_error   ;

/***  WORK  ***/

non terminal SDPSymbol  token ;
non terminal SDPSymbol tokens;
non terminal SDPSymbol optTokens ;

non terminal SDPSymbol opt_all       ;
non terminal SDPSymbol opt_by        ;
non terminal SDPSymbol opt_comma     ;
non terminal SDPSymbol opt_data      ;
non terminal SDPSymbol opt_date_fmt  ;
non terminal SDPSymbol opt_in        ;
non terminal SDPSymbol opt_key       ;
non terminal SDPSymbol opt_to        ;
non terminal SDPSymbol opt_with      ;

non terminal SDPSymbol optword_than  ;
non terminal SDPSymbol optword_to    ;

precedence nonassoc LPAR, RPAR    ;

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/*                        INICIO PARSER                               */
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

cobolCode ::=  module {: code.EndOfFile(lastStmt, hasEndProgram);
                         RESULT = null;  
                      :}
          ; 

module ::= procedure_division  end_program ;

end_program  ::= END_PGM:s SYM ENDP {: hasEndProgram = true; 
                                      StmtCobol stmt = new StmtCobol(s); 
                                      code.endProgram(stmt);
                                      lastStmt = stmt;
                                   :}
             |
             ;


/*********************************************************************/
/* Procedure division                                                */
/*********************************************************************/
                                             
procedure_division ::= proc_div_header bloque_procedure
                   ;

proc_div_header    ::= PROC_DIV:s  resto_call:p {: code.beginCode(s); :}
                   ;

resto_call         ::=  proc_parms_list:p {: RESULT = p; :} 
                        ENDP:s          {: code.parrafoVirtual(s); :}
                   ;

proc_parms_list ::= proc_parms 
                |              
                ;
                 
proc_parms ::= proc_parm
           |   proc_parms proc_parm
           ;
              
proc_parm ::= USING list_parms_opt 
          |   RETURNING rvalue 
          ;

list_parms_opt ::= list_parms
               |
               ;
                                                
list_parms ::= SYM:s               {: RESULT = new Tokens(s); :}
           |   list_parms:l SYM:s  {: RESULT = l.add(s);      :} 
           ;
                                         
bloque_procedure ::= bloque_inicial  lista_parrafos  ;

// Bloque sentences podria ser vacio
// Por eso no es necesario indicarlo en bloque_inicial                 

bloque_inicial  ::= bloque_sentences
                ;

lista_parrafos ::= bloque_parrafos
               |
               ;
               
bloque_parrafos ::= bloque_parrafo
                |   bloque_parrafos bloque_parrafo
                ;
                
bloque_parrafo   ::= parrafo_name  bloque_sentences
                 ;

bloque_sentences ::= lista_stmt  
                 |               
                 ;
                        
parrafo_name ::= PARRAFO:p parr_section:b ENDP 
                 {: // if (b == true) code.notSupportedSection(p); 
                    RESULT = code.processParagraph(p, lastStmt); 
                 :}   
             ;  
 
parr_section     ::= SECTION:s {: RESULT = true;  :}
                 |             {: RESULT = false; :}
                 ;                               
                 
lista_stmt ::= stmt:s             {: lastStmt = code.processStatement(s, lastStmt); :} 
           |   lista_stmt stmt:s  {: lastStmt = code.processStatement(s, lastStmt); :}
           ;

stmt     ::= verbos:s         {: RESULT = s; code.incStmt(s); :}
         |   noverbos:s       {: RESULT = s; :}
         |   directives:s     {: RESULT = s; rules.checkCobolDirective(s); :}
         ;  

directives ::= dir_trace:s    {: RESULT = s; :}
           ;
           
dir_trace ::= READY:s TRACE  {: RESULT = new StmtCobol(s, code.getNumStatements()); :} 
          |   RESET:s TRACE  {: RESULT = new StmtCobol(s, code.getNumStatements()); :} 
          ;
          
verbos   ::= stmtControl:s    {: s.setGroup(CDG.STMT_CONTROL); RESULT = s; module.incStmtControl(); :}
         |   stmtFlujo:s      {: s.setGroup(CDG.STMT_FLOW);    RESULT = s; module.incStmtFlujo();   :}
         |   stmtDatos:s      {: s.setGroup(CDG.STMT_DATA);    RESULT = s; module.incStmtDatos();   :}
         |   stmtArit:s       {: s.setGroup(CDG.STMT_ARIT);    RESULT = s; module.incStmtArit();    :}
         |   stmtIO:s         {: s.setGroup(CDG.STMT_IO);      RESULT = s; module.incStmtIO();      :}
         |   stmtLang:s       {: s.setGroup(CDG.STMT_LANG);    RESULT = s; module.incStmtLang();    :}       
         |   stmtCics:s       {: s.setGroup(CDG.STMT_CICS);    RESULT = s; module.incStmtCics();    :}
         |   stmtSQL:s        {: s.setGroup(CDG.STMT_SQL);     RESULT = s; module.incStmtSql();     :}         
         ;

noverbos ::= stmtEndP:s        {: RESULT = code.checkFlujo( s, lastStmt);:}
         |   stmtEndVerb:s     {: RESULT = code.endVerb(s);           :}
         |   stmtWhen:s        {: RESULT = code.processWhen(s);       :}
         |   stmtElse:s        {: RESULT = code.processElse(s);       :}         
         |   stmtAtEnd:s       {: RESULT = s;                         :}  
         |   stmtInvalid:s     {: RESULT = s;                         :}         
         |   stmtException:s   {: RESULT = s;                         :}         
         ;
  
/* Verbos que tienen tratamiento especial
 * Cuando se procesa el verbo, se inyecta codigo
 * En estos casos hay que inyectar el codigo y preparar el siguiente
 * En el bloque todavia no se ha contado la sentencia If
 */
          

/* Sentencias de control de programa */

stmtControl ::= stmtControl1:s optTokens:t {: RESULT = s;          :}
             |  stmtExit:s                 {: RESULT =  code.processExit(s);    :}    
             |  stmtControl2:s             {: hasEndProgram = true; RESULT = s; :}
             ;
            
stmtControl1 ::= stmtNext:s         {: RESULT = s; :}
             ;

stmtControl2 ::= stmtStop:s         {: hasEndProgram = true;
                                       RESULT = s; 
                                       code.trapEndModule(); 
                                   :}
             | stmtGoback:s       {:  hasEndProgram = true;
                                      code.trapEndModule();
                                      RESULT = s; 
                                   :}
             ;
             

/* Sentencias de control de flujo */

stmtFlujo ::= stmtPerform:s     {: RESULT = s; :}
          |   stmtCall:s        {: RESULT = s; :}
          |   stmtIf:s          {: RESULT = s; :}
          |   stmtEvaluate:s    {: RESULT = s; :}
          |   stmtGoTo:s        {: RESULT = s; :}
          |   stmtContinue:s    {: RESULT = s; :}
          |   stmtSearch:s      {: RESULT = s; :}          
          ;
             
/* Sentencias de manipulacion de datos */

stmtDatos ::= stmtMove:s           {: RESULT = s; :}
          |   stmtString:s         {: RESULT = s; :}
          |   stmtInspect:s        {: RESULT = s; :}
          |   stmtUnstring:s       {: RESULT = s; :}
          |   stmtInitialize:s     {: RESULT = s; :}
          |   stmtSet:s            {: RESULT = s; :}
          ;
            
/* Sentencias de entrada/salida */

stmtIO    ::= stmtIO1:s optTokens:t {: RESULT = s; :}
          |   stmtIO2:s             {: RESULT = s; :}
          ;
          
stmtIO1   ::= stmtMerge:s          {: RESULT = s; :}
          |   stmtStart:s          {: RESULT = s; :}
          ;

stmtIO2 ::= stmtAccept:s         {: RESULT = s; :}
        |   stmtDisplay:s        {: RESULT = s; :}
        |   stmtOpen:s           {: RESULT = s; :}
        |   stmtClose:s          {: RESULT = s; :}
        |   stmtRead:s           {: RESULT = s; :}
        |   stmtRelease:s        {: RESULT = s; :}          
        |   stmtReturn:s         {: RESULT = s; :}
        |   stmtWrite:s          {: RESULT = s; :}
        |   stmtDelete:s         {: RESULT = s; :}
        |   stmtRewrite:s        {: RESULT = s; :}
        |   stmtSort:s           {: RESULT = s; :}        
        ;
                    
/* Sentencias de operaciones aritmeticas */
stmtArit ::= stmtMultiply:s    {: RESULT = s; :}
         |   stmtCompute:s     {: RESULT = s; :}
         |   stmtAdd:s         {: RESULT = s; :}
         |   stmtDivide:s      {: RESULT = s; :}
         |   stmtSubtract:s    {: RESULT = s; :}
//         |   stmtTest:s        {: RESULT = s; :}
         ;
            
/* Sentencias del lenguaje */

stmtLang    ::= stmtCancel:s      {: RESULT = s; :}
            ;

/* Verbos */
                                                   

stmtContinue    ::=  CONTINUE:s   {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;



stmtGoback      ::=  GOBACK:s     {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;
stmtMerge       ::=  MERGE:s      {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;


moduloCall ::= variable:i  {: RESULT = i; :}
           |   LITERAL:l {: RESULT = l; :}
           ;
                
// EXIT PERFORM crea un conflicto:
//   .....
//   EXIT
//   PERFORM .....
//
// por eso se controla EXIT PERFORM en el analizador lexico

stmtExit        ::= exitTypes:s   {: RESULT = s; :}
                ;

exitTypes ::= stmtExitG:s {: RESULT = s; :} 
          |   stmtExitP:s {: RESULT = s; :}
          |   stmtExitPgm:s {: RESULT = s; :}
          ;  
                        
stmtExitG ::=  EXIT:s  exitType:t   {: StmtCobol stmt = new StmtCobol(s, code.getNumStatements());
                                       RESULT = stmt.addRValue(t); 
                                    :}    
          ;

stmtExitP ::=  EXIT_PERFORM:s  {: StmtCobol stmt = new StmtCobol(s, code.getNumStatements());
                           RESULT = stmt.addRValue(code.makeSymbol(ZCCSym.PERFORM, -1, -1, "PERFORM")); 
                        :}    
          ;

stmtExitPgm ::=  EXIT_PGM:s  {: StmtCobol stmt = new StmtCobol(s, code.getNumStatements());
                               RESULT = stmt.addRValue(s); 
                            :}
            ;                    

exitType  ::= PROGRAM:s   {: RESULT = s; :}
          |   SECTION:s   {: RESULT = s; :}
          |               {: RESULT = code.makeSymbol(ZCCSym.PARRAFO, -1, -1, ""); :}
          ;
          
stmtNext     ::=  NEXT:s       {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;

stmtReturn   ::=  RETURN:r  SYM:i stmtRead_detail:j     
                  {: StmtCobol stmt = code.fileAccess(TRAP.ACC_READ, r, i);
                     RESULT = stmt; // .addTokens(j); 
                  :}
             ;
stmtCics ::= CICSCODE:s {: RESULT = new StmtCobol(s, code.getNumStatements()); :}
         ;
         
              
stmtSQL ::= SQLCODE:s  {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     
        ;

stmtEndExec ::= ENDEXEC:s {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     
            ;
            
/*************************************************************************************/
/*************************************************************************************/
/***                     STATEMENT DETAILS                                         ***/ 
/*************************************************************************************/
/*************************************************************************************/

// ACCEPT

stmtAccept ::=  accept_verb:s lvalue accept_from   {: RESULT = new StmtCobol(s); :}     
           ;

accept_verb ::= ACCEPT:s {: RESULT = new StmtCobol(s, currStmt); :}
            ;
            
accept_from ::= FROM accept_data
            ;

accept_data ::= SYM
            |   DATE opt_date_fmt
            |   DAY  opt_date_fmt
            |   DAY_OF_WEEK
            |   TIME             
            ;
                         

// ADD

stmtTest ::= ADD rvalue TO lvalue {: RESULT = currStmt; :}
         ;
         
stmtAdd ::=  add_verb rvalue_options_opt rvalue_list TO lvalue_list add_options_opt {: RESULT = currStmt; :}     
        ;
             
add_verb ::= ADD:s  {: currStmt = new StmtCobol(s); :}
         ;
         
add_options_opt ::= add_options
                |
                ;
                                  
add_options ::= add_option
            |   add_options add_option
            ;
                
add_option ::= option_giving
           |   option_rounded
           |   option_corr
           ;

// CALL

stmtCall ::=  CALL:s moduloCall:i 
                     stmtCall_using_opt
                     stmtCall_returning_opt      {: RESULT = code.processCall(s, i); :}     
         ;

stmtCall_using_opt ::= stmtCall_using
                   |
                   ;
                     
stmtCall_using ::= USING stmtCall_parm_list
               ;

stmtCall_parm_list ::= stmtCall_parm
                   |   stmtCall_parm_list stmtCall_parm
                   ;
               
stmtCall_parm ::= rvalue
              |   BY stmtCall_parm_type
              ;
              
stmtCall_parm_type ::= VALUE
                   |   REFERENCE
                   ;

stmtCall_returning_opt ::= stmtCall_returning
                       |
                       ;
                       
stmtCall_returning ::= RETURNING lvalue
                   ;
                                                                                      
// CANCEL

stmtCancel ::= CANCEL:s rvalue  {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;               

// COMPUTE 

stmtCompute  ::=  COMPUTE:s compute_lvalue REL_EQ compute_rvalues compute_options_opt
                   {: StmtCobol stmt = new StmtCobol(s, code.getNumStatements());
//                      stmt.addSymbol(i);
                      RESULT = stmt; 
                   :}     
              ;

compute_lvalue ::= lvalue:i rvalue_options_opt
               ;

compute_rvalues ::= compute_rvalue
                |   compute_rvalues compute_rvalue
                ;                   
                   
compute_rvalue ::= expression
               ;

compute_options_opt ::= compute_options
                    |
                    ;
                        
compute_options ::= compute_option
                |   compute_options compute_option
                ;

compute_option ::= option_size_error
                   ;
// DISPLAY

stmtDisplay ::= DISPLAY:s rvalue_list {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     
            ;
                                                                                              
// DIVIDE

stmtDivide ::= divide_verb:s rvalue divide_mode divide_options_opt      {: RESULT = s; :}
           ;

divide_verb ::= DIVIDE:s {: RESULT = new StmtCobol(s, currStmt); :}
            ;

divide_mode ::= INTO lvalue_list
            |   BY   rvalue_list
            ;

divide_options_opt ::= divide_options
                   |
                   ;

divide_options ::= divide_option:o                
               |   divide_options divide_option:o 
               ;

divide_option ::= option_giving:o    {: currStmt.addOption(o); :}
              |   option_rounded:o   {: currStmt.addOption(o); :}
              |   option_remainder:o {: currStmt.addOption(o); :}
              ;
                                                                      
// EVALUATE

stmtEvaluate ::=  evaluate_verb:s evaluate_object {: RESULT = code.processEvaluate(s); :}  
             ;

evaluate_verb ::= EVALUATE:s {: RESULT = new StmtCobol(s, currStmt);  :}
              ;
              
evaluate_object ::= logical_condition
                    ;

stmtWhen ::=  when_verb:s when_condition {: RESULT = s; :}
         ;

when_verb ::= WHEN:s {: RESULT = new StmtCobol(s, currStmt); :}
          ; 
          
when_condition ::= when_item
               |   when_other:o {: currStmt.addOption(new Option(o)); :}
               ;
                                                     
when_item ::= logical_condition:t when_thru
//        |   when_item ALSO logical_condition:t when_thru
                  /*
                    {: RESULT = new StmtCobol(s, currStmt);
                        // stmt.addTokens(t);   
                    :} 
                  */  
          ;

when_other ::= OTHER:o {: RESULT = o; :}
           ;
                    
when_thru ::= THRU logical_condition
          |
          ;
                  
// GO TO

stmtGoTo ::=  GOTO:s opt_to 
                     stmtGoto_procs 
                     stmtGoto_depending_opt   
                     {: RESULT = new StmtCobol(s, code.getNumStatements()); :} 
         ;

stmtGoto_procs ::= SYM
               |   stmtGoto_procs SYM
               ;

stmtGoto_depending_opt ::= stmtGoto_depending
                       |
                       ;
                       
stmtGoto_depending ::= DEPENDING rvalue
                   ;
                                                          
// IF

stmtIf ::= if_verb:s logical_condition:l {:  RESULT = code.processIf(s); :}
       ;

if_verb ::= IF:s {: RESULT = new StmtCobol(s, currStmt); :}
        ;
                       
// INITIALIZE

stmtInitialize  ::=  initialize_verb:s initialize_detail {: RESULT = s;  :}     
                ;

initialize_verb ::=  INITIALIZE:s {: RESULT = new StmtCobol(s, currStmt); :}
                ;
                               
initialize_detail ::= lvalue_list initialize_rep_opt
                  ;
                      
initialize_rep_opt ::= REPLACING:r {: currOption = new Option(r); :} initialize_rep_lst {: currStmt.addOption(currOption); :} 
                   |
                   ;

initialize_rep_lst ::= initialize_rep
                   |   initialize_rep_lst initialize_rep
                   ;

initialize_rep ::= figurative opt_data BY initialize_rep_val
               ;
               
initialize_rep_val ::= rvalue:v   {: currOption.addSymbol(v); :}
                   ;
                                                                                                          
// INSPECT

stmtInspect ::=  INSPECT:s rvalue:l stmtInspect_detail
                                {: RESULT = new StmtCobol(s); :}     
            ;

stmtInspect_detail ::= stmtInspect_token
                   |   stmtInspect_detail stmtInspect_token
                   ;

stmtInspect_token ::= ALL
                |     BY
                |     BEFORE
                |     AFTER
                |     LEADING
                |     FIRST
                |     CHARACTER
                |     TO
                |     TALLYING
                |     REPLACING
                |     CONVERTING
                |     rvalue
                ;
                   

// MOVE

stmtMove ::= move_verb:s rvalue_options_opt expression:r TO lvalue_list:l      
                   {: code.checkCall(l, r);
                      s.addRValue(r);
                      s.addLValue(l);
                      RESULT = s; 
                   :}     
              ;

move_verb ::= MOVE:s {: RESULT = new StmtCobol(s, currStmt); :}
          ;
           
// MULTIPLY

stmtMultiply ::=  MULTIPLY:s stmtMultiply_detail {: RESULT = new StmtCobol(s, code.getNumStatements()); :}
             ;
             
stmtMultiply_detail ::= stmtMultiply_by multiply_options_opt
                   ;
                   
stmtMultiply_by ::= rvalue BY rvalue
                ;

multiply_options_opt ::= multiply_options
                     |
                     ;
                     
multiply_options ::= multiply_option
                 |   multiply_options multiply_option
                 ;
                 
multiply_option ::= option_giving
                |   option_size_error
                ;
                
// OPEN

stmtOpen ::=  OPEN:o stmtOpen_list:l 
                   {: RESULT = code.fileAction(TRAP.ACC_OPEN, o, l); :} 
         ;

stmtOpen_list ::= stmtOpen_group:s                  {: RESULT = s;         :}
              |   stmtOpen_list:l stmtOpen_group:s  {: RESULT = l.add(s);  :}
              ;

stmtOpen_group  ::= stmtOpen_mode:o stmtOpen_files:l 
                 {: Persistence f;
                 /*JGG
                    for (Symbol s : l.getTokens()) {
                        f = module.getFile(getSymbolName(s));
                        f.setAccess(o.getId());
                    }
                    */
                    RESULT = l;
                 :}
              ; 

stmtOpen_mode ::= INPUT:s   {: StmtCobol stmt = new StmtCobol(s);
                               stmt.setId(Persistence.INPUT);
                               RESULT = stmt; 
                            :}
              |   OUTPUT:s  {: StmtCobol stmt = new StmtCobol(s);
                               stmt.setId(Persistence.OUTPUT);
                               RESULT = stmt;
                            :}
              |   IO:s     {: StmtCobol stmt = new StmtCobol(s);
                               stmt.setId(Persistence.IO);
                               RESULT = stmt;
                            :}
              |   EXTEND:s  {: StmtCobol stmt = new StmtCobol(s);
                               stmt.setId(Persistence.EXTEND);
                               RESULT = stmt;
                            :}
              ;      

stmtOpen_files ::= SYM:s                    {: RESULT = new Tokens(s); :}
               |   stmtOpen_files:l SYM:s   {: RESULT = l.add(s);      :}
               ;

                
// PERFORM
// Caso 1: PERFORM inline
// Caso 2: PERFORM PARRAFO X TIMES (Por eso from es recursivo
// Caso 3: PERFORM PARRAFO OPCIONES
// Caso 4: PERFORM PARRAFO OPCIONES X TIMES
// El caso TIMES NECESITA TRATAMIENTO ESPECIAL

stmtPerform ::=  perform_verb perform_from   {: RESULT = code.processPerform(currStmt, lastStmt); :} 
            ;

perform_verb ::= PERFORM:s  {: currStmt = new StmtCobol(s); :}
             ;

perform_from ::= perform_label perform_options_label_opt
             |   perform_options_opt
             ;

perform_label ::= variable:v {: currStmt.addOption(new Option(v)); :}
              ;

perform_options_opt ::= perform_options
                    |
                    ;

perform_options_label_opt ::= perform_options_label
                          |
                          ;

perform_options_label ::= perform_option_first:o                         {: currStmt.addOption(o); :}
                      |   perform_option_times:o                         {: currStmt.addOption(o); :}
                      |   perform_options_label perform_option_second:o  {: currStmt.addOption(o); :}
                      ;
                      
perform_option_times ::= variable:o {: RESULT = new Option(o); :}
                     |   NUMERO:o   {: RESULT = new Option(o); :}
                     ;
                                               
perform_options ::= perform_option_first:o                    {: currStmt.addOption(o); :}
                |   perform_options perform_option_second:o   {: currStmt.addOption(o); :}
                ;

perform_option_first ::= TIMES:o             {: currStmt.replaceOption(new Option(o)); :}
                     |   perform_until:o     {: RESULT = o; :} 
                     |   perform_thru:o      {: RESULT = o; :}
                     |   perform_varying:o   {: RESULT = o; :}
                     |   perform_after:o     {: RESULT = o; :}                         
                     |   perform_test:o      {: RESULT = o; :}
                     ;
                   
perform_option_second ::= perform_option_first:o  {: RESULT = o;                :}
                      |   var_int:v               {: RESULT = new Option(v); :}
                      ;

perform_thru ::= THRU:o id:i                   {: RESULT = new Option(o, i); :}
             ;
             
perform_until ::= UNTIL:o   logical_condition:t        {: RESULT = new Option(o); :}
              ;
              
perform_varying ::= VARYING:o var_int FROM var_int BY var_int
                ; 

perform_after ::= AFTER:o var_int FROM var_int BY var_int
                ; 
                                     
perform_test ::= TEST:o    BEFORE {: RESULT = new Option(o);    :}
             |   TEST:o    AFTER  {: RESULT = new Option(o);    :}
             ;

// READ

stmtRead     ::=  READ:r  SYM:i stmtRead_detail:s     
                  {: StmtCobol stmt = code.fileAccess(TRAP.ACC_READ, r, i);
                     RESULT = stmt; 
                  :}
             ;

stmtRead_detail ::= stmtRead_options
                |
                ;
                
stmtRead_options ::= stmtRead_option
                 |   stmtRead_options stmtRead_option
                 ;

stmtRead_option ::= stmtRead_into
                |   stmtRead_key
                ;
                
stmtRead_into ::= INTO:i lvalue:d {: Tokens t = new Tokens(i); RESULT = t.add(d); :}
              ;
              
stmtRead_key ::= KEY rvalue
             ;              

// SEARCH

stmtSearch ::= search_verb:s opt_all search_detail {: RESULT = code.processSearch(s); :}
           ;

search_verb ::= SEARCH:s  {: RESULT = currStmt = new StmtCobol(s); :}
            ;
                       
search_detail ::= rvalue search_options 
              ;
                  
search_options ::= search_option
               |
               ;
                                     
search_option ::= search_opt
              |   search_option search_opt
              ;
                  
search_opt ::= search_varying
           ;
               
search_varying ::= VARYING rvalue
               ;
                   
// SET

stmtSet ::=  set_verb:s set_list       {: RESULT = s; :}     
        ;

set_verb ::= SET:s {: RESULT = new StmtCobol(s, currStmt); :}
         ;
         
set_list ::= set_item
         |   set_list set_item
         ;

set_item ::= set_lvalue set_rvalue
         ;
                  
set_lvalue ::= lvalue_list 
           ;

set_rvalue ::= set_variable
           |   set_index
           ;

set_variable ::= TO set_value
             |   BY set_value
             ;
          
set_index ::= set_index_inc rvalue
          ;
          
set_index_inc ::= UP BY
              |   DOWN BY
              ;
              
set_value ::= rvalue
          |   FALSE
          |   TRUE
          |   ON
          |   OFF
          ;
                                                                      
// SORT

stmtSort ::= SORT:s {: RESULT = new StmtCobol(s); :} SYM stmtSort_detail
         ;
         
stmtSort_detail ::= stmtSort_option
                |   stmtSort_detail stmtSort_option
                ;

stmtSort_option ::= stmtSort_order
                |   stmtSort_duplicates
                |   stmtSort_using
                |   stmtSort_giving
                |   stmtSort_procedure                
                ;
                
stmtSort_order ::= option_order opt_key rvalue_list
               ;                       
               
stmtSort_duplicates ::= DUPLICATES 
                    ;
                    
stmtSort_using ::= USING rvalue_list 
               ;

stmtSort_giving ::= GIVING rvalue_list 
               ;

stmtSort_procedure ::= INPUT SYM
                   |   OUTPUT SYM
                   ;
                                                                                      
// START

stmtStart ::= START:s SYM stmtStart_key    {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     ;

stmtStart_key ::= KEY logical_oper rvalue
              |
              ;        

// STRING

stmtString ::=  string_verb:s string_from string_into   {: RESULT = s; :} 
           ; 

string_verb ::= STRING:s {: RESULT = new StmtCobol(s, currStmt); :}
            ;

string_from ::= string_from_item 
            |   string_from string_from_item 
            ; 

string_from_item ::= rvalue_list string_delimited
                 ;
                 
string_delimited ::= DELIMITED  opt_by string_delimited_token
                 ;
                                
string_delimited_token ::= rvalue
                       |   SIZE
                       ;

string_into ::= INTO lvalue string_pointer_opt
            ;
                
string_pointer_opt ::= opt_with POINTER lvalue
                   |
                   ;
                                        
                                                                
// SUBTRACT

stmtSubtract ::= SUBTRACT:s stmtSubtract_detail {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     
             ;
             
stmtSubtract_detail ::= rvalue_list stmtSubtract_options
                    ;

stmtSubtract_options ::= stmtSubtract_option
                     |   stmtSubtract_options stmtSubtract_option
                     ;
                     
stmtSubtract_option ::= FROM rvalue_list 
                    |   option_giving
                    |   option_size_error
                    ;
// UNSTRING

stmtUnstring ::=  UNSTRING:s  stmtUnstring_detail {: RESULT = new StmtCobol(s, code.getNumStatements()); :}     
             ;

stmtUnstring_detail ::= rvalue stmtUnstring_delimited_opt stmtUnstring_to stmtUnstring_options_opt 
                    ;
                     
stmtUnstring_delimited_opt ::= stmtUnstring_delimited
                           |
                           ;
                                                 
stmtUnstring_delimited ::= DELIMITED opt_by opt_all stmtUnstring_delimiteds
                       ;
                    
stmtUnstring_delimiteds ::= stmtUnstring_delimited_token
                        |   stmtUnstring_delimiteds stmtUnstring_delimited_token
                        ;
                        
stmtUnstring_delimited_token ::= rvalue
                             |   OR
                             ;
                                                   
stmtUnstring_to ::= INTO stmtUnstring_targets 
                ;

stmtUnstring_targets ::= stmtUnstring_target
                     |   stmtUnstring_targets stmtUnstring_target
                     ;

stmtUnstring_target ::= lvalue stmtUnstring_delimiters_opt
                    ;
                     
stmtUnstring_delimiters_opt ::= stmtUnstring_delimiters
                           |
                           ;
                           
stmtUnstring_delimiters ::= stmtUnstring_delimiter
                        |   stmtUnstring_delimiters stmtUnstring_delimiter
                        ;
                        
stmtUnstring_delimiter ::= DELIMITER opt_in lvalue 
                       |   COUNT opt_in lvalue
                       ;

stmtUnstring_options_opt ::= stmtUnstring_options
                         |
                         ;
                         
stmtUnstring_options ::= stmtUnstring_option
                     |   stmtUnstring_options stmtUnstring_option
                     ;
                     
stmtUnstring_option ::= POINTER   lvalue
                    |   TALLYING  opt_in lvalue
                    |   optionOverflow
                    ; 
// WRITE

stmtWrite    ::=  WRITE:w SYM:i stmtWrite_detail 
                  {: RESULT = code.fileAccess(TRAP.ACC_INSERT, w, i); :}       
             ;
stmtRewrite  ::=  REWRITE:r SYM:i  stmtWrite_detail 
                  {: RESULT = code.fileAccess(TRAP.ACC_UPDATE, r, i); :}
             ;

stmtWrite_detail ::= stmtWrite_options
                 |
                 ;
                 
stmtWrite_options ::= stmtWrite_option
                  |   stmtWrite_options stmtWrite_option
                  ;

stmtWrite_option ::= stmtWrite_from
                 |   stmtWrite_position
                 |   stmtWrite_after
                 |   stmtWrite_eop
                 ;
                                                  
stmtWrite_from ::= FROM rvalue
               ;

stmtWrite_position ::= option_position rvalue
                   ;
                
stmtWrite_after ::= AFTER
                ;
                                
stmtWrite_eop ::= EOP:s {: code.setImperative(); 
                                   RESULT = new StmtCobol(s); 
                                :}                         
              ;
                     
stmtRelease  ::=  RELEASE:s  SYM:i eatWrite:e  
                  {: StmtCobol stmt = new StmtCobol(s);
                     RESULT = stmt.addLValue(i);
                  :}     
             ;

stmtDelete   ::=  DELETE:d SYM:i      
                 {: RESULT = code.fileAccess(TRAP.ACC_DELETE, d, i); :}
             ;

stmtStop     ::=  STOP:s     optTokens  {: RESULT = new StmtCobol(s, code.getNumStatements()); :}    
             |    STOPRUN:s  optTokens  {: RESULT = new StmtCobol(s, code.getNumStatements()); :}
             ;

stmtClose       ::=  CLOSE:c  closeLstFiles:l  
                    {: RESULT = code.fileAction(TRAP.ACC_CLOSE, c, l); :}
                ;

closeLstFiles   ::= closeFile:c                  {: RESULT = c;         :}
                |   closeLstFiles:l closeFile:c  {: RESULT = l.add(c);  :}
                ;

closeFile       ::= SYM:s eatClose:e   {: Tokens t = new Tokens(s);
                                         RESULT = t.add(e); 
                                      :}
                ;


stmtAtEnd ::= AT:s END:v     {: StmtCobol stmt = new StmtCobol(s);
                             RESULT = code.setAtEnd(stmt); 
                          :}
          ;

stmtInvalid       ::= INVALID:s opt_key    {: StmtCobol stmt = new StmtCobol(s);
                                              RESULT = code.setAtEnd(stmt); 
                                           :}
                ;

stmtException ::= EXCEPTION:s  {: RESULT = new StmtCobol(s); :}
              ;
                                                      
/**************************************************************/     
/* Opciones comunes                                           */
/**************************************************************/

rvalue_options_opt ::= rvalue_options
                   |
                   ;

rvalue_options ::= rvalue_option
               |   rvalue_options rvalue_option    
               ;
               
rvalue_option ::= option_all
              |   option_corr
              |   option_rounded
              ;
                              
option_all ::= ALL:o {: RESULT = new Option(o); :}
           ;

option_corr ::= CORR:o {: RESULT = new Option(o); :}
            ;

option_giving ::= GIVING:o lvalue_list {: RESULT = new Option(o); :}
              ;
             
option_rounded ::= ROUNDED:r  {: currStmt.addOption(new Option(r)); :}
               ;
               
optionOverflow  ::= OVERFLOW:i  {: code.setImperative(); 
                                   RESULT = new StmtCobol(i); 
                                :}
                ;

option_remainder ::= REMAINDER:o lvalue  {: RESULT = new Option(o); :}
                 ;
                               
option_size_error ::= SIZE_ERROR:i {: code.setImperative(); 
                                   RESULT = new Option(i); 
                                :}
                  ;
                  
                       
option_position ::= BEFORE
                |   AFTER
                ;

option_order ::= ASCENDING
             |   DESCENDING
             ;

/**************************************************************/     
/* Otras palabras reservadas                                  */
/**************************************************************/

stmtEndP        ::= ENDP:s         {: RESULT = new StmtCobol(s); RESULT.setEndPoint(true); :} ;
stmtElse        ::= ELSE:s         {: RESULT = new StmtCobol(s); :} ;   
stmtEndVerb     ::= ENDVERB:s      {: RESULT = s;                :} ;
                                       
///////////////////////////////////////////////////////
// No terminales para eliminar el resto de las sentencias
//////////////////////////////////////////////////////

eatClose ::= eatCloseLst:l {: RESULT = l;            :}
         |                 {: RESULT = new Tokens(); :}
         ;

eatCloseLst ::= eatCloseItem:i               {: RESULT = new Tokens(i); :}
            |   eatCloseLst:l eatCloseItem:i {: RESULT = l.add(i);      :}
            ;

eatCloseItem ::= WITH:s {: RESULT = new Tokens(s); :}
             |   NO:s   {: RESULT = new Tokens(s); :}
             |   FOR:s  {: RESULT = new Tokens(s); :}
             ;

    
eatWrite ::= eatWriteLst:l {: RESULT = l;            :}
         |                 {: RESULT = new Tokens(); :}
         ;

eatWriteLst ::= eatWriteItem:e               {: RESULT = new Tokens(e); :}
            |   eatWriteLst:x eatWriteItem:i {: RESULT = x.add(i);      :}
            ;

eatWriteItem ::= token:s {: RESULT = new Tokens(s); :} 
             |   WITH:s  {: RESULT = new Tokens(s); :}
             |   LOCK:s  {: RESULT = new Tokens(s); :}
             |   NO:s    {: RESULT = new Tokens(s); :}
             |   LINE:s  {: RESULT = new Tokens(s); :}
             |   PAGE:s  {: RESULT = new Tokens(s); :}
             |   AFTER:s  {: RESULT = new Tokens(s); :}
             ;

/*****************************************************************/
/*****************************************************************/
/***              EXPRESION ARITMETICA                         ***/
/*****************************************************************/
/*****************************************************************/

expression ::= expression_arit:e {: RESULT = e; :} 
           ;
            
expression_arit ::= expr_operand:e                                 {: RESULT = e; :}
                |   expression_arit:e operator_arit expr_operand   {: RESULT = e; :}
                ;

expr_colon ::= expression:e expr_colon_opt {: RESULT = e; :}
           ;
           
expr_colon_opt ::= OP_COLON expr_colon_value:e {: RESULT = e;    :}
               |                               {: RESULT = null; :}
               ;

expr_colon_value ::= expr_primary:e {: RESULT = e;    :}
                 |                  {: RESULT = null; :}
                 ;
                                           
expr_operand ::= expr_primary:e           {: RESULT = e; :}
             |   LPAR expr_colon:e RPAR   {: RESULT = e; :}
             ;

expr_primary ::= rvalue:e                 {: RESULT = e; :}
             ;

                                        
/*****************************************************************/
/*****************************************************************/
/***              EXPRESION LOGICA                             ***/
/*****************************************************************/
/*****************************************************************/

logical_oper ::= logical_oper_not 
             |   GREATER optword_than logical_oper_or_opt
             |   EQUAL
             |   REL_EQ
             |   REL_GT
             |   REL_GE
             ;

logical_oper_not ::= NOT logical_oper_not_value
                 ;
                               
logical_oper_not_value ::= LESS
                       |   REL_LT
                       ;
                                                      
logical_oper_or_opt ::= OR EQUAL optword_to
                    |
                    ;
                                 
// Casos
// IF TRUE
// IF VAR88
// IF PPEPE NUMERIC

logical_condition ::= logical_begin:w      {: RESULT = w;                 :}                
                 |    logical_condition:w  
                      logical_and_or:w1    
                      logical_next:w2      {: RESULT = w.add(w1.add(w2)); :}
                 ;

logical_begin ::= logical_not:w      {: RESULT = w;                 :}
              ;

logical_next ::= NOT:w logical_op_opt:w1 logical_unary:w2  {: RESULT = w.add(w1.add(w2)); :} 
             |   logical_op:w logical_unary:w2             {: RESULT = w.add(w2);         :}
             |   logical_yes:w                             {: RESULT = w;                 :}
             ;
                           
logical_not ::= logical_unary_not:w                        {: RESULT = w;                 :}
            |   logical_not:w NOT:w1 logical_relation:w2   {: RESULT = w.add(w1.add(w2)); :}
            |   logical_not:w        logical_relation:w2   {: RESULT = w.add(w2);         :}
            ;

logical_yes ::= logical_unary:w                            {: RESULT = w;                 :}
            |   logical_yes:w NOT:w1 logical_relation:w2   {: RESULT = w.add(w1.add(w2)); :}
            |   logical_yes:w        logical_relation:w2   {: RESULT = w.add(w2);         :}
            ;
            
logical_relation ::= logical_class:w                       {: RESULT = w;         :}
                 |   logical_op:w logical_unary:w2         {: RESULT = w.add(w2); :}
                 ;
                 
logical_unary_not ::= NOT logical_unary:w {: RESULT = w; :}
                  |   logical_unary:w     {: RESULT = w; :}
                  ;
                                                   
logical_unary ::= logical_expr:w                 {: RESULT = w; :}
              |   logical_class:w                {: RESULT = w; :}
              |   LPAR logical_condition:w RPAR  {: RESULT = w.setFunction(); :}
              ;                   

logical_expr ::= logical_operand:l                                {: RESULT = l; :}
             |   logical_expr:l operator_arit:o logical_operand:r {: RESULT = l.add(o.add(r)); :} 
             ;

logical_operand ::= expr_primary:l {: RESULT = l; :}
            ;

logical_op_opt ::= logical_op:l    {: RESULT = l; :}
               |
               ;
               
logical_op ::= REL_EQ:l {: RESULT = l; :}
           |   REL_GT:l {: RESULT = l; :}
           |   REL_GE:l {: RESULT = l; :}
           |   REL_LT:l {: RESULT = l; :}
           |   REL_LE:l {: RESULT = l; :}
           |   logical_rel:l {: RESULT = l; :}
           ;

logical_rel ::= logical_figurative:l                    {: RESULT = l; :} 
            |   logical_rel:l OR:o logical_figurative:r {: RESULT = code.add(l,o,r); :}
            ;
            
logical_figurative ::= EQUAL:l opt_to:o {: RESULT = code.add(l,o);    :}
                   |   GREATER:l        {: RESULT = new SDPSymbol(l); :}
                   |   LESS:l           {: RESULT = new SDPSymbol(l); :} 
                   ;                                          

logical_class ::= TRUE:l       {: RESULT = l; :}
              |   FALSE:l      {: RESULT = l; :}
              |   POSITIVE:l   {: RESULT = l; :}
              |   NEGATIVE:l   {: RESULT = l; :}
              |   NULL:l       {: RESULT = l; :}
              |   NUMERIC:l    {: RESULT = l; :}
              |   ALPHABETIC:l {: RESULT = l; :}
              ;
              
  
logical_and_or ::= AND:a    {: RESULT = a; code.incComplexity(); :}
               |   OR:o     {: RESULT = o; code.incComplexity(); :}
               |   ALSO:a   {: RESULT = a; code.incComplexity(); :}
               ;
  
///////////////////////////////////////////////////////
// WORK
//////////////////////////////////////////////////////

optTokens ::= tokens:t        {: RESULT = t;    :}
          |                   {: RESULT = null; :}
          ;
           
tokens ::= token:t            {: RESULT = t;          :}
       |   tokens:t token:w2  {: RESULT = t.add(w2);  :}
       ;
 
token ::= SYM:w               {: RESULT = w; :}
      |   LITERAL:w           {: RESULT = w; :}
      |   NUMERO:w            {: RESULT = w; :} 
      |   figurative:w        {: RESULT = w; :}
      |   FILLER:w            {: RESULT = w; :}
      |   LPAR tokens:w RPAR  {: RESULT = w.setFunction();  :}      
      ;

figurative ::= POSITIVE:w     {: RESULT = w; :}
           |   NEGATIVE:w     {: RESULT = w; :}
           |   ALPHABETIC:w   {: RESULT = w; :}
           |   ALPHANUMERIC:w {: RESULT = w; :}           
           |   NUMERIC:w      {: RESULT = w; :}           
           |   KANJI:w        {: RESULT = w; :}
           |   DBCS:w         {: RESULT = w; :}           
           |   EGCS:w         {: RESULT = w; :}
           |   NATIONAL:w     {: RESULT = w; :}              
           |   NULL:w         {: RESULT = w; :}
           ;

function ::= FUNCTION:f INTRINSIC:i function_parms:p {: RESULT = f.add(i.add(p.setFunction())); :} 
         |   LENGTH:l OF:s rvalue:r                  {: RESULT = l.add(s.add(r)); :} 
         ;

function_parms ::= LPAR function_parms_lst_opt:w RPAR {: RESULT = w; :}
               ;

function_parms_lst_opt ::= function_parms_lst:o {: RESULT = o; :}
                       |
                       ;
                               
function_parms_lst ::= function_parm:w                              {: RESULT = w; :}
                   |   function_parms_lst:w COMMA  function_parm:w2 {: RESULT = w.setComma().add(w2);  :}
                   ;
                   
function_parm ::= expr_colon:o {: RESULT = o; :}
              |   literal:o    {: RESULT = o; :}
              ;

operator_arit ::= OP_ADD:o {: RESULT = o; :}
              |   OP_SUB:o {: RESULT = o; :}
              |   OP_MUL:o {: RESULT = o; :}
              |   OP_DIV:o {: RESULT = o; :}
              |   OP_POW:o {: RESULT = o; :}
              ;

/*****************************************************************/
/*****************************************************************/
/*** IDENTIFICADORES  LVALUES   RVALUES                        ***/
/*****************************************************************/
/*****************************************************************/

lvalue ::= variable:i  {: RESULT = i; code.setVarWrite(i); :}  
       ;
       
lvalue_list ::= lvalue:w                             {: RESULT = w; :}
            |   lvalue_list:w opt_comma:c lvalue:w2  {: RESULT = w.setComma(c).add(w2);   :}
            ;
                   
rvalue_list ::= rvalue:w                             {: RESULT = w; :} 
            |   rvalue_list:w opt_comma:c rvalue:w2  {: RESULT = w.setComma(c).add(w2);   :}
            ;

rvalue ::= variable:i    {: RESULT = i;  code.setVarRead(i); :}
       |   constantes:c  {: RESULT = c; :}
       |   function:f    {: RESULT = new SDPSymbol(f);    :}
       ;

variable ::= var_base:w  padres_opt:p {: RESULT = w.setParent(p);    :}
         ;

var_base ::= id:i indices_opt:r {: RESULT = code.add(i,r); :}
        ;

var_int ::= rvalue:l {: RESULT = l; :}
        ;
             
id ::= SYM:i  {: RESULT = new SDPSymbol(i); :} 
   ;


indices_opt ::= indices:l       {: RESULT = l;        :}
            |
            ;
            
indices ::= indice:l            {: RESULT = l;             :}
        |   indices:t indice:l  {: RESULT = code.add(t,l); :}
        ;
        
indice ::= LPAR:s indice_lst:i RPAR:l   {: RESULT = code.add(s,i,l);  :}
       ;

indice_lst ::= indice_item:w                        {: RESULT = w;               :}
           |   indice_lst:w COMMA:c indice_item:w2  {: RESULT = w.setComma().add(w2); :}
           ;

indice_item ::= expr_colon:w {: RESULT = w;        :} 
            ;
                                 
padres_opt ::= padres:w      {: RESULT = w;        :}
           |                 {: RESULT = null;     :}
           ;
                                                   
padres ::= padre:w            {: RESULT = w;                :}
       |   padres:w padre:w2  {: RESULT = w.setParent(w2);; :}
       ;

padre ::= IN var_base:w {: RESULT = w; :}
      |   OF var_base:w {: RESULT = w; :}
      ;
             
constantes ::= constante:c   {: RESULT = c; :}
//           |   figurative:f  {: f.setId(ZCZSym.FIGURATIVE); RESULT = f; :}
           ;
            
constante  ::= LITERAL:l     {: RESULT = new SDPSymbol(l); :}
           |   NUMERO:n      {: RESULT = new SDPSymbol(n); :}
           |   DFHCICS:d     {: RESULT = new SDPSymbol(d); :}
           |   SPACES:f      {: RESULT = new SDPSymbol(f); :}
           |   ZERO:f        {: RESULT = new SDPSymbol(f); :}
           |   HIGHVAL:f     {: RESULT = new SDPSymbol(f); :}
           |   LOWVAL:f      {: RESULT = new SDPSymbol(f); :}           
           ;


/*****************************************************************/
/***  TERMINOS OPCIONALES                                      ***/
/*****************************************************************/

opt_all ::= ALL:s {: RESULT = s; :}
        |
        ;
                                                      
opt_by ::= BY:s {: RESULT = s; :}
       |
       ;

opt_comma ::= COMMA:s  {: RESULT = s;    :} //JGG Avisar del uso de coma
          |            {: RESULT = null; :}
          ;

opt_data ::= DATA:s  {: RESULT = s; :} 
         |
         ;

// Puede ser YYYYMMDD o YYYYDDD
// Pero se devuelve como symbol

opt_date_fmt ::= SYM
             |
             ;
             
opt_in ::= IN:s {: RESULT = s; :}
       |
       ;

opt_to ::= TO:s {: RESULT = s; :}
       |
       ;
                                                                                   
opt_key ::= KEY:s {: RESULT = s; :}
        |
        ;

opt_with ::= WITH:s {: RESULT = s; :}
         |
         ;
          
optword_than ::= THAN:s  {: RESULT = s; :}
        |
        ;        
        
optword_to ::= TO:s  {: RESULT = s; :}
           |
           ;                